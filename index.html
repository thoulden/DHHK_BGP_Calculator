<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Balanced vs Explosive Growth Path Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f7;
      color: #222;
      display: flex;
      justify-content: center;
    }
    .container {
      max-width: 900px;
      width: 100%;
      padding: 24px;
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 20px 24px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
      margin-bottom: 20px;
    }
    h1 {
      font-size: 1.6rem;
      margin: 0 0 8px;
    }
    h2 {
      font-size: 1.2rem;
      margin-top: 0;
    }
    .subtitle {
      color: #555;
      font-size: 0.95rem;
      margin-bottom: 16px;
    }
    .sliders {
      display: grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      gap: 18px 24px;
    }
    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .slider-group label {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .slider-output {
      grid-column: span 1;
    }
    .slider-alpha {
      grid-column: span 2;
    }
    .value-display {
      font-size: 0.85rem;
      color: #555;
    }
    input[type="range"] {
      width: 100%;
    }
    .result-box {
      border-radius: 10px;
      padding: 12px 14px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
      margin-top: 12px;
    }
    .result-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #666;
      margin-bottom: 4px;
    }
    .result-value {
      font-size: 1.3rem;
      font-weight: 700;
    }
    .result-sub {
      margin-top: 6px;
      font-size: 0.85rem;
      color: #444;
      line-height: 1.4;
    }
    .ok-status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .ok-status.ok {
      background: #e6f6ea;
      color: #1b6a32;
      border: 1px solid #b8e2c4;
    }
    .ok-status.error {
      background: #fde8e7;
      color: #b02a1c;
      border: 1px solid #f5b5af;
    }
    .footer {
      margin-top: 8px;
      font-size: 0.75rem;
      color: #777;
    }
    .checkbox-row {
      margin-top: 16px;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    /* Tooltip styles for the ⓘ next to "Results" */
    .tooltip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      cursor: pointer;
      margin-left: 6px;
      color: #777;
      transition: color 0.2s ease-in-out;
      user-select: none;
      position: relative;
    }
    .tooltip:hover {
      color: #000;
    }
    .tooltiptext {
      visibility: hidden;
      width: 260px;
      background-color: #333;
      color: #fff;
      text-align: left;
      padding: 10px;
      border-radius: 6px;
      position: absolute;
      z-index: 10;
      top: 26px;
      left: 0;
      opacity: 0;
      transition: opacity 0.25s ease-in-out;
      font-size: 0.8rem;
      line-height: 1.35;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 700px) {
      .sliders {
        grid-template-columns: minmax(0, 1fr);
      }
      .slider-output,
      .slider-alpha {
        grid-column: span 1;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Balanced vs Explosive Growth Path Calculator</h1>
      <p class="subtitle">
        Adjust the automation parameters <strong>f<sub>Y</sub></strong>, <strong>f<sub>S</sub></strong>, 
        <strong>f<sub>A</sub></strong>, <strong>f<sub>H</sub></strong>, and labor share <strong>α</strong>.<br/>
        Optionally edit the returns to research. The app computes balanced growth
        relative to the no-automation case (with the same returns to research and labor share).
      </p>

      <!-- Automation & alpha sliders -->
      <div class="sliders">
        <!-- ROW 1: alpha + output -->
        <div class="slider-group slider-alpha">
          <label for="alpha">Labor Share (α)</label>
          <input type="range" id="alpha" min="0.01" max="0.99" step="0.01" value="0.60" />
          <div class="value-display">Current: <span id="alpha-value">0.60</span></div>
        </div>
        
        <div class="slider-group slider-output">
          <label for="fY">
            % Automation of Output Tasks (f<sub>Y</sub>)
          </label>
          <input type="range" id="fY" min="0" max="1" step="0.001" value="0" />
          <div class="value-display">Current: <span id="fY-value">0%</span></div>
        </div>

        <!-- ROW 2: three tech sliders (software, hardware, TFP) -->
        <div class="slider-group">
          <label for="fz">% Automation of Software Research Tasks (f<sub>S</sub>)</label>
          <input type="range" id="fz" min="0" max="1" step="0.001" value="0" />
          <div class="value-display">Current: <span id="fz-value">0%</span></div>
        </div>

        <div class="slider-group">
          <label for="fh">% Automation of Hardware Research Tasks (f<sub>H</sub>)</label>
          <input type="range" id="fh" min="0" max="1" step="0.001" value="0" />
          <div class="value-display">Current: <span id="fh-value">0%</span></div>
        </div>

        <div class="slider-group">
          <label for="fA">% Automation of TFP Research Tasks (f<sub>A</sub>)</label>
          <input type="range" id="fA" min="0" max="1" step="0.001" value="0" />
          <div class="value-display">Current: <span id="fA-value">0%</span></div>
        </div>
      </div>

      <!-- Checkbox to edit returns to research -->
      <div class="checkbox-row">
        <label>
          <input type="checkbox" id="editReturns" />
          Edit Returns to Research
        </label>
      </div>

      <!-- Returns to research sliders (hidden until checkbox is checked) -->
      <div id="returns-sliders" class="sliders" style="display:none; margin-top:8px;">
        <div class="slider-group">
          <label for="rz">Return to Software Research (r<sub>S</sub>)</label>
          <input type="range" id="rz" min="0" max="10" step="0.01" value="1.00" />
          <div class="value-display">Current: <span id="rz-value">1.00</span></div>
        </div>

        <div class="slider-group">
          <label for="rh">Return to Hardware Research (r<sub>H</sub>)</label>
          <input type="range" id="rh" min="0" max="10" step="0.01" value="5.00" />
          <div class="value-display">Current: <span id="rh-value">5.00</span></div>
        </div>

        <div class="slider-group">
          <label for="rA">Return to TFP Research (r<sub>A</sub>)</label>
          <input type="range" id="rA" min="0" max="10" step="0.01" value="0.32" />
          <div class="value-display">Current: <span id="rA-value">0.32</span></div>
        </div>
      </div>

      <div class="card" style="margin-top:18px;">
        <h2>
          Results
          <span class="tooltip">ⓘ
            <span class="tooltiptext">
              How many times larger is the balanced growth path for output, hardware,
              and software under automation inputs compared to this path under no automation?
              The balanced growth path multiplier on TFP is the same as that for output.
            </span>
          </span>
        </h2>
        <div id="status" class="ok-status"></div>

        <div class="result-box">
          <div class="result-title">Output BGP multiplier over no automation</div>
          <div class="result-value" id="ratio">–</div>
          <div class="result-sub">
            Software Multiplier: <span id="soft-mult">–</span><br>
            Hardware Multiplier: <span id="hard-mult">–</span><br>
            TFP Multiplier: <span id="tfp-mult">–</span>
          </div>
        </div>

        <div class="footer">
          By default, returns to research are fixed at: r<sub>S</sub> = 1, r<sub>H</sub> = 5, r<sub>A</sub> = 0.32.
          Tick “Edit Returns to Research” to change them.
        </div>
      </div>
    </div>
  </div>

  <script>
    // Base parameters (n fixed, rS/rH/rA can be edited)
    const baseParams = {
      n: 0.01,
      rS: 1,   // software
      rH: 5,   // hardware
      rA: 0.32 // TFP
    };

    // Utility: 3x3 matrix inverse
    function invert3x3(m) {
      const a = m[0][0], b = m[0][1], c = m[0][2];
      const d = m[1][0], e = m[1][1], f = m[1][2];
      const g = m[2][0], h = m[2][1], i = m[2][2];

      const det =
        a * (e * i - f * h) -
        b * (d * i - f * g) +
        c * (d * h - e * g);

      if (!Number.isFinite(det) || Math.abs(det) < 1e-12) {
        return { ok: false, inv: null };
      }

      const invDet = 1 / det;

      const inv = [
        [
          (e * i - f * h) * invDet,
          (c * h - b * i) * invDet,
          (b * f - c * e) * invDet
        ],
        [
          (f * g - d * i) * invDet,
          (a * i - c * g) * invDet,
          (c * d - a * f) * invDet
        ],
        [
          (d * h - e * g) * invDet,
          (b * g - a * h) * invDet,
          (a * e - b * d) * invDet
        ]
      ];

      return { ok: true, inv };
    }

    // Utility: multiply 3x3 by 3x1
    function matVec3x3(m, v) {
      return [
        m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2],
        m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2],
        m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2]
      ];
    }

    // Core: compute gy2 for given f's, alpha, and returns to research (Section 5 structure)
    // Order of sectors: [Software (S); Hardware (H); TFP (A)]
    function computeGy2(fY, fz, fA, fh, alpha, params) {
      const { n, rS, rH, rA } = params;

      const fS = fz;   // software
      const fH = fh;   // hardware
      const fTFP = fA; // TFP

      if (alpha <= 0 || alpha >= 1) {
        return { ok: false, value: NaN, gA: null };
      }

      const r = [rS, rH, rA];           // baseline returns
      const fVec = [fS, fH, fTFP];      // research automation
      const sigma = [1, 1, 0];          // relevance for AI capabilities
      const tau = [0, 0, 1];            // tech contributions to TFP

      // 1. Automation-adjusted returns r_hat
      const denom_rhat = r.map((ri, i) => 1 - fVec[i] * sigma[i] * ri);
      if (denom_rhat.some(x => x <= 0 || !Number.isFinite(x))) {
        return { ok: false, value: NaN, gA: null };
      }
      const rHat = r.map((ri, i) => ri / denom_rhat[i]);

      // 2. Technological spillovers F_A
      const F_A = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ];
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (i !== j) {
            F_A[i][j] = fVec[i] * sigma[j] * rHat[i];
          }
        }
      }

      // 3. Economic feedback matrix F_Y
      const oneMinusFY = 1 - fY;
      if (oneMinusFY <= 0) {
        return { ok: false, value: NaN, gA: null };
      }

      const alphaEff = alpha * oneMinusFY;
      if (alphaEff <= 0) {
        return { ok: false, value: NaN, gA: null };
      }

      const dgY_dgA = tau.map((tj, j) => tj / alphaEff + (fY / oneMinusFY) * sigma[j]);

      const F_Y = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ];
      for (let i = 0; i < 3; i++) {
        const ci = fVec[i] * rHat[i];
        for (let j = 0; j < 3; j++) {
          F_Y[i][j] = ci * dgY_dgA[j];
        }
      }

      // 4. Leontief inverse & BGP tech growth
      const F = [
        [F_A[0][0] + F_Y[0][0], F_A[0][1] + F_Y[0][1], F_A[0][2] + F_Y[0][2]],
        [F_A[1][0] + F_Y[1][0], F_A[1][1] + F_Y[1][1], F_A[1][2] + F_Y[1][2]],
        [F_A[2][0] + F_Y[2][0], F_A[2][1] + F_Y[2][1], F_A[2][2] + F_Y[2][2]]
      ];

      const IminusF = [
        [1 - F[0][0], -F[0][1], -F[0][2]],
        [-F[1][0], 1 - F[1][1], -F[1][2]],
        [-F[2][0], -F[2][1], 1 - F[2][2]]
      ];

      const invRes = invert3x3(IminusF);
      if (!invRes.ok) {
        return { ok: false, value: NaN, gA: null };
      }
      const Psi = invRes.inv;

      const rHatTimesN = rHat.map(x => x * n);
      const gA_BGP = matVec3x3(Psi, rHatTimesN);

      if (!gA_BGP.every(Number.isFinite)) {
        return { ok: false, value: NaN, gA: null };
      }

      // 5. Output growth and per-capita gy
      const tauEff = tau.map((tj, j) => tj + fY * sigma[j]);
      let tauDotgA = 0;
      for (let j = 0; j < 3; j++) {
        tauDotgA += tauEff[j] * gA_BGP[j];
      }

      const gY_BGP = tauDotgA / alphaEff + n;
      const gy2 = gY_BGP - n;

      if (!Number.isFinite(gy2)) {
        return { ok: false, value: NaN, gA: null };
      }

      return { ok: true, value: gy2, gA: gA_BGP };
    }

    // Hook up UI
    const sliders = ["fY", "fz", "fA", "fh", "alpha", "rz", "rh", "rA"];
    const values = {
      fY: document.getElementById("fY-value"),
      fz: document.getElementById("fz-value"),
      fA: document.getElementById("fA-value"),
      fh: document.getElementById("fh-value"),
      alpha: document.getElementById("alpha-value"),
      rz: document.getElementById("rz-value"),
      rh: document.getElementById("rh-value"),
      rA: document.getElementById("rA-value")
    };

    const ratioSpan = document.getElementById("ratio");
    const softSpan  = document.getElementById("soft-mult");
    const hardSpan  = document.getElementById("hard-mult");
    const tfpSpan   = document.getElementById("tfp-mult");
    const statusDiv = document.getElementById("status");
    const editReturnsCheckbox = document.getElementById("editReturns");
    const returnsSlidersDiv   = document.getElementById("returns-sliders");

    function setSubMultipliers(soft, hard, tfp) {
      softSpan.textContent = soft;
      hardSpan.textContent = hard;
      tfpSpan.textContent  = tfp;
    }

    // Generic multiplier formatter (when math is defined)
    function formatMultiplier(num, den) {
      if (!Number.isFinite(num) || !Number.isFinite(den) || den === 0) {
        return "∞ ×";
      }
      const r = num / den;
      if (!Number.isFinite(r)) {
        return "∞ ×";
      }
      if (r < 0) {
        return "-";
      }
      return r.toFixed(4) + " ×";
    }

    function applyZeroFRules(fY, fS, fH, fTFP, outputMult, softMult, hardMult, tfpMult) {
      // If f_i = 0, force multiplier to 1.0000 ×
      // Exception: if fA > 0 and fY = 0, output multiplier may change.
      if (fY === 0 && !(fTFP > 0 && fY === 0)) {
        outputMult = "1.0000 ×";
      }
      if (fS === 0) {
        softMult = "1.0000 ×";
      }
      if (fH === 0) {
        hardMult = "1.0000 ×";
      }
      if (fTFP === 0) {
        tfpMult = "1.0000 ×";
      }
      return { outputMult, softMult, hardMult, tfpMult };
    }

    function explosionMultipliers(fY, fS, fH, fTFP) {
      // When the system truly explodes (no BGP, inverse fails):
      // Apply your "fi=0 => multiplier=1" rule; otherwise ∞ ×.
      let outputMult, softMult, hardMult, tfpMult;

      if (fY === 0 && !(fTFP > 0 && fY === 0)) {
        outputMult = "1.0000 ×";
      } else {
        outputMult = "∞ ×";
      }

      softMult = (fS === 0) ? "1.0000 ×" : "∞ ×";
      hardMult = (fH === 0) ? "1.0000 ×" : "∞ ×";
      tfpMult  = (fTFP === 0) ? "1.0000 ×" : "∞ ×";

      return { outputMult, softMult, hardMult, tfpMult };
    }

    function update() {
      const fY    = parseFloat(document.getElementById("fY").value);
      const fz    = parseFloat(document.getElementById("fz").value);  // software
      const fA    = parseFloat(document.getElementById("fA").value);  // TFP
      const fh    = parseFloat(document.getElementById("fh").value);  // hardware
      const alpha = parseFloat(document.getElementById("alpha").value);

      const fS   = fz;
      const fH   = fh;
      const fTFP = fA;

      // Update displayed numeric values for automation & alpha
      values.fY.textContent = (fY * 100).toFixed(1) + "%";
      values.fz.textContent = (fz * 100).toFixed(1) + "%";
      values.fA.textContent = (fA * 100).toFixed(1) + "%";
      values.fh.textContent = (fh * 100).toFixed(1) + "%";
      values.alpha.textContent = alpha.toFixed(2);

      // Decide which returns to research to use
      const editReturns = editReturnsCheckbox.checked;
      let rS = baseParams.rS;
      let rH = baseParams.rH;
      let rA = baseParams.rA;

      if (editReturns) {
        rS = parseFloat(document.getElementById("rz").value);
        rH = parseFloat(document.getElementById("rh").value);
        rA = parseFloat(document.getElementById("rA").value);

        values.rz.textContent = rS.toFixed(2);
        values.rh.textContent = rH.toFixed(2);
        values.rA.textContent = rA.toFixed(2);
      }

      const paramSet = {
        n: baseParams.n,
        rS,
        rH,
        rA
      };

      // Compute gy2 & gA for current f's and for f=0 benchmark
      const resCurrent = computeGy2(fY, fz, fA, fh, alpha, paramSet);
      const resZero    = computeGy2(0, 0, 0, 0, alpha, paramSet);

      // If either solve fails (no BGP at all), use manual explosion rules.
      if (!resCurrent.ok || !resZero.ok || !Number.isFinite(resCurrent.value) || !Number.isFinite(resZero.value)) {
        statusDiv.textContent = "System Explodes (no BGP)";
        statusDiv.className = "ok-status error";

        const { outputMult, softMult, hardMult, tfpMult } =
          explosionMultipliers(fY, fS, fH, fTFP);

        ratioSpan.textContent = outputMult;
        setSubMultipliers(softMult, hardMult, tfpMult);
        return;
      }

      // Normal BGP case: compute ratios, then enforce fi=0 rules.
      let outputMult = formatMultiplier(resCurrent.value, resZero.value);
      let softMult = "–", hardMult = "–", tfpMult = "–";

      if (resCurrent.gA && resZero.gA) {
        softMult = formatMultiplier(resCurrent.gA[0], resZero.gA[0]); // S
        hardMult = formatMultiplier(resCurrent.gA[1], resZero.gA[1]); // H
        tfpMult  = formatMultiplier(resCurrent.gA[2], resZero.gA[2]); // A
      }

      // Apply your "fi=0 => 1.0000 ×" rule (with the fA>0 & fY=0 exception for output)
      ({ outputMult, softMult, hardMult, tfpMult } =
        applyZeroFRules(fY, fS, fH, fTFP, outputMult, softMult, hardMult, tfpMult));

      // In the BGP case we just declare the system balanced.
      statusDiv.textContent = "System has a Balanced Growth Path.";
      statusDiv.className = "ok-status ok";

      ratioSpan.textContent = outputMult;
      setSubMultipliers(softMult, hardMult, tfpMult);
    }

    // Attach listeners
    const sliders = ["fY", "fz", "fA", "fh", "alpha", "rz", "rh", "rA"];
    sliders.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener("input", update);
      }
    });

    editReturnsCheckbox.addEventListener("change", () => {
      returnsSlidersDiv.style.display = editReturnsCheckbox.checked ? "grid" : "none";
      update();
    });

    // Initial computation
    update();
  </script>
</body>
</html>


